// backend/services/oracleService.js
const oracledb = require('oracledb');
const ScrapedDataHistory = require('../models/ScrapedDataHistory');
const logger = require('../utils/logger');

class OracleService {
  constructor() {
    this.connection = null;
    this.config = {
      user: process.env.ORACLE_USER,
      password: process.env.ORACLE_PASSWORD,
      connectString: process.env.ORACLE_CONNECTION_STRING,
      connectTimeout: 5 // 5 second timeout instead of 20
    };
  }

  async connect() {
    try {
      if (!this.connection) {
        this.connection = await oracledb.getConnection(this.config);
        logger.debug('Oracle DB connected');
      }
      return this.connection;
    } catch (error) {
      logger.error('Oracle connection error:', error.message);
      // Throw a more user-friendly error
      const err = new Error('Oracle database unavailable. This feature requires VPN access.');
      err.code = 'ORACLE_UNAVAILABLE';
      err.statusCode = 503;
      throw err;
    }
  }a

  async getFootballRoster(teamId, seasonYear) {
    try {
      const conn = await this.connect();

      const query = `
        SELECT r.PLAYER_ID, r.MONIKER, r.LAST_NAME, r.TEAM_ID,
               r.TEAM_NAME, r.TEAM_NICKNAME, r.HEIGHT, r.WEIGHT,
               r.UNIFORM, r.POSITION_DESC, r.POSITION_ABBR,
               r.CLASS, r.ELIGIBILITY, p.HOMETOWN_CITY
       |~FOOTBALL_ROSTER r
        LEFT JOIN GLOBAL.GLB_PEOPLE p ON r.PLAYER_ID = p.PERSON_ID
        WHERE r.LEAGUE_ID = 16
          AND r.STATUS = 'Y'
          AND r.YEAR_LAST = :seasonYear
          AND r.TEAM_ID = :teamId
      `;

      const result = await conn.execute(query, {
        seasonYear: seasonYear || new Date().getFullYear(),
        teamId: teamId
      });
      
      return this.transformOracleData(result);
    } catch (error) {
      logger.error('Oracle query error:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch football roster: ${error.message}`);
    }
  }

  async getMensBasketballRoster(teamId, seasonYear) {
    try {
      const conn = await this.connect();

      const query = `
        SELECT r.PLAYER_ID, r.MONIKER, r.LAST_NAME, r.TEAM_ID,
               r.TEAM_NAME, r.TEAM_NICKNAME, r.HEIGHT, r.WEIGHT,
               r.UNIFORM_NUMBER, r.POSITION_NAME, r.POSITION_ABBREV,
               r.CLASS, r.ELIGIBILITY, p.HOMETOWN_CITY
        FROM CUSTOMER_DATA.CD_BK_ROSTER r
        LEFT JOIN GLOBAL.GLB_PEOPLE p ON r.PLAYER_ID = p.PERSON_ID
        WHERE r.LEAGUE_ID = 2
          AND r.STATUS = 'Y'
          AND r.YEAR_LAST = :seasonYear
          AND r.TEAM_ID = :teamId
      `;

      const result = await conn.execute(query, {
        seasonYear: seasonYear || new Date().getFullYear(),
        teamId: teamId
      });

      return this.transformOracleData(result);
    } catch (error) {
      logger.error('Oracle men\'s basketball query error:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch men's basketball roster: ${error.message}`);
    }
  }

  async getWomensBasketballRoster(teamId, seasonYear) {
    try {
      const conn = await this.connect();

      const query = `
        SELECT r.PLAYER_ID, r.MONIKER, r.LAST_NAME, r.TEAM_ID,
               r.TEAM_NAME, r.TEAM_NICKNAME, r.HEIGHT, r.WEIGHT,
               r.UNIFORM_NUMBER, r.POSITION_NAME, r.POSITION_ABBREV,
               r.CLASS, r.ELIGIBILITY, p.HOMETOWN_CITY
        FROM CUSTOMER_DATA.CD_BK_ROSTER r
        LEFT JOIN GLOBAL.GLB_PEOPLE p ON r.PLAYER_ID = p.PERSON_ID
        WHERE r.LEAGUE_ID = 5
          AND r.STATUS = 'Y'
          AND r.YEAR_LAST = :seasonYear
          AND r.TEAM_ID = :teamId
      `;

      const result = await conn.execute(query, {
        seasonYear: seasonYear || new Date().getFullYear(),
        teamId: teamId
      });
1;kmdwkpnefon





;
    } catch (error) {
      logger.error('Oracle women\'s basketball query error:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch women's basketball roster: ${error.message}`);
    }
  }

  // Keep old method for backwards compatibility
  async getBasketballRoster(teamId, seasonYear, gender = 'M') {
    if (gender === 'M') {    
      return this.getMensBasketballRoster(teamId, seasonYear);
    } else {
      return this.getWomensBasketballRoster(teamId, seasonYear);
    }
  }

  // Get football game info from CD_CFB_GAMES
  async getFootballGame(teamId, gameDate, seasonId) {
    try {
      const conn = await this.connect();

      // Convert gameDate from "2025-09-27" to Oracle DATE format
      const query = `
        SELECT SEASON_ID, GAME_DATE_CT, GAME_DATE, HOME_TEAM, AWAY_TEAM,
               HOME_SCORE, AWAY_SCORE, NEUTRAL_SITE, LOCATION, ATTENDANCE
        FROM CUSTOMER_DATA.CD_CFB_GAMES
        WHERE SEASON_ID = :seasonId
          AND (HOME_TEAM = :teamId OR AWAY_TEAM = :teamId)
          AND TRUNC(GAME_DATE_CT) = TO_DATE(:gameDate, 'YYYY-MM-DD')
      `;

      const result = await conn.execute(query, {
        seasonId,
        teamId,
        gameDate
      });

      if (result.rows && result.rows.length > 0) {
        const row = result.rows[0];
        return {
          seasonId: row[0],
          gameDateCt: row[1],
          gameDate: row[2],
          homeTeam: row[3],
          awayTeam: row[4],
          homeScore: row[5],
          awayScore: row[6],
          neutralSite: row[7],
          location: row[8],
          attendance: row[9],
          source: 'oracle'
        };
      }
      return null;
    } catch (error) {
      logger.error('Error fetching football game from Oracle:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch football game: ${error.message}`);
    }
  }

  // Get football offensive stats from CD_CFB_OGST
  async getFootballOffensiveStats(teamId, gameDate, seasonId) {
    try {
      const conn = await this.connect();

      // Query CD_CFB_OGST for game-by-game offensive stats (passing, rushing, receiving only)
      const query = `
        SELECT PLAYER_ID, TEAM_ID, FIRST_NAME, LAST_NAME,
               COMP, ATT, PASS_YD, PASS_TD, INT, PASS_LNG,
               SACKED, SACKED_YD_LST, QB_RATING,
               RUSH, RUSH_YD, RUSH_AVG, RUSH_TD, RUSH_LNG,
               RECEPT, REC_YD, REC_AVG, REC_TD, REC_LNG
        FROM CUSTOMER_DATA.CD_CFB_OGST
        WHERE SEASON_ID = :seasonId
          AND TEAM_ID = :teamId
          AND SPLIT_NUMBER = 0
          AND TRUNC(GAME_DATE_CT) = TO_DATE(:gameDate, 'YYYY-MM-DD')
      `;

      const result = await conn.execute(query, {
        seasonId,
        teamId,
        gameDate
      });

      if (!result.rows || result.rows.length === 0) {
        return [];
      }

      // Transform to match our data structure
      return result.rows.map(row => ({
        playerId: row[0],
        teamId: row[1],
        firstName: row[2],
        lastName: row[3],
        fullName: row[2] ? `${row[2]} ${row[3]}` : row[3], // Handle null firstName (e.g., Team player)
        jersey: null, // Not available in this table
        passing: {
          completions: row[4] || 0,
          attempts: row[5] || 0,
          yards: row[6] || 0,
          tds: row[7] || 0,
          ints: row[8] || 0,
          long: row[9] || 0,
          sacks: row[10] || 0,
          sacksYardsLost: row[11] || 0,
          rating: row[12] || 0
        },
        rushing: {
          attempts: row[13] || 0,
          yards: row[14] || 0,
          average: row[15] || 0,
          tds: row[16] || 0,
          long: row[17] || 0
        },
        receiving: {
          receptions: row[18] || 0,
          yards: row[19] || 0,
          average: row[20] || 0,
          tds: row[21] || 0,
          long: row[22] || 0
        },
        source: 'oracle'
      }));
    } catch (error) {
      logger.error('Error fetching football offensive stats from Oracle:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch football offensive stats: ${error.message}`);
    }
  }

  async getFootballPuntingStats(teamId, gameDate, seasonId) {
    try {
      const conn = await this.connect();

      // Query CD_CFB_PGST for punting stats (player-level)
      const query = `
        SELECT PLAYER_ID, TEAM_ID, FIRST_NAME, LAST_NAME,
               PUNT, PUNT_YDS, PUNT_LNG
        FROM CUSTOMER_DATA.CD_CFB_PGST
        WHERE SEASON_ID = :seasonId
          AND TEAM_ID = :teamId
          AND SPLIT_NUMBER = 0
          AND TRUNC(GAME_DATE_CT) = TO_DATE(:gameDate, 'YYYY-MM-DD')
      `;

      const result = await conn.execute(query, {
        seasonId,
        teamId,
        gameDate
      });

      if (!result.rows || result.rows.length === 0) {
        return [];
      }

      // Transform to match our data structure
      return result.rows.map(row => ({
        playerId: row[0],
        teamId: row[1],
        firstName: row[2],
        lastName: row[3],
        fullName: row[2] ? `${row[2]} ${row[3]}` : row[3], // Handle null firstName (e.g., Team player)
        punting: {
          punts: row[4] || 0,
          yards: row[5] || 0,
          long: row[6] || 0
        },
        source: 'oracle'
      }));
    } catch (error) {
      logger.error('Error fetching football punting stats from Oracle:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch football punting stats: ${error.message}`);
    }
  }

  async getFootballReturnsStats(teamId, gameDate, seasonId) {
    try {
      const conn = await this.connect();

      // Query CD_CFB_RGST for punt and kick returns (player-level)
      const returnsQuery = `
        SELECT PLAYER_ID, TEAM_ID, FIRST_NAME, LAST_NAME,
               PUNT_RET, PUNT_RET_YD, PUNT_RET_LNG,
               KICK_RET, KICK_RET_YD, KICK_RET_LNG
        FROM CUSTOMER_DATA.CD_CFB_RGST
        WHERE SEASON_ID = :seasonId
          AND TEAM_ID = :teamId
          AND SPLIT_NUMBER = 0
          AND TRUNC(GAME_DATE_CT) = TO_DATE(:gameDate, 'YYYY-MM-DD')
      `;

      // Query CD_CFB_DGST for interception returns (player-level)
      const intQuery = `
        SELECT PLAYER_ID, TEAM_ID, FIRST_NAME, LAST_NAME,
               INT, INT_YD, INT_LNG
        FROM CUSTOMER_DATA.CD_CFB_DGST
        WHERE SEASON_ID = :seasonId
          AND TEAM_ID = :teamId
          AND SPLIT_NUMBER = 0
          AND TRUNC(GAME_DATE_CT) = TO_DATE(:gameDate, 'YYYY-MM-DD')
      `;

      const [returnsResult, intResult] = await Promise.all([
        conn.execute(returnsQuery, { seasonId, teamId, gameDate }),
        conn.execute(intQuery, { seasonId, teamId, gameDate })
      ]);

      // Merge returns data by player
      const playerReturnsMap = new Map();

      // Add punt/kick returns
      if (returnsResult.rows && returnsResult.rows.length > 0) {
        returnsResult.rows.forEach(row => {
          const playerId = row[0];
          const fullName = row[2] ? `${row[2]} ${row[3]}` : row[3]; // Handle null firstName (e.g., Team player)

          playerReturnsMap.set(playerId, {
            playerId: row[0],
            teamId: row[1],
            firstName: row[2],
            lastName: row[3],
            fullName,
            returns: {
              puntReturns: row[4] || 0,
              puntReturnYards: row[5] || 0,
              puntReturnLong: row[6] || 0,
              kickReturns: row[7] || 0,
              kickReturnYards: row[8] || 0,
              kickReturnLong: row[9] || 0,
              interceptions: 0,
              interceptionYards: 0,
              interceptionLong: 0
            },
            source: 'oracle'
          });
        });
      }

      // Add interception returns
      if (intResult.rows && intResult.rows.length > 0) {
        intResult.rows.forEach(row => {
          const playerId = row[0];
          const fullName = row[2] ? `${row[2]} ${row[3]}` : row[3]; // Handle null firstName (e.g., Team player)

          const existing = playerReturnsMap.get(playerId);
          if (existing) {
            // Player already has punt/kick returns, add interceptions
            existing.returns.interceptions = row[4] || 0;
            existing.returns.interceptionYards = row[5] || 0;
            existing.returns.interceptionLong = row[6] || 0;
          } else {
            // Player only has interception returns
            playerReturnsMap.set(playerId, {
              playerId: row[0],
              teamId: row[1],
              firstName: row[2],
              lastName: row[3],
              fullName,
              returns: {
                puntReturns: 0,
                puntReturnYards: 0,
                puntReturnLong: 0,
                kickReturns: 0,
                kickReturnYards: 0,
                kickReturnLong: 0,
                interceptions: row[4] || 0,
                interceptionYards: row[5] || 0,
                interceptionLong: row[6] || 0
              },
              source: 'oracle'
            });
          }
        });
      }

      return Array.from(playerReturnsMap.values());
    } catch (error) {
      logger.error('Error fetching football returns stats from Oracle:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch football returns stats: ${error.message}`);
    }
  }

  // Get basketball game info from CD_BK_GAMES
  async getBasketballGame(teamId, gameDate, seasonId, gender = 'M') {
    try {
      const conn = await this.connect();
      const leagueId = gender === 'M' ? 2 : 5; // 2 = Men's, 5 = Women's

      const query = `
        SELECT SEASON_ID, GAME_DATE_CT, GAME_DATE, HOME_TEAM, AWAY_TEAM,
               HOME_SCORE, AWAY_SCORE, NEUTRAL_SITE, LOCATION, ATTENDANCE
        FROM CUSTOMER_DATA.CD_BK_GAMES
        WHERE SEASON_ID = :seasonId
          AND LEAGUE_ID = ${leagueId}
          AND (HOME_TEAM = :teamId OR AWAY_TEAM = :teamId)
          AND TRUNC(GAME_DATE_CT) = TO_DATE(:gameDate, 'YYYY-MM-DD')
      `;

      const result = await conn.execute(query, {
        seasonId,
        teamId,
        gameDate
      });

      if (result.rows && result.rows.length > 0) {
        const row = result.rows[0];
        return {
          seasonId: row[0],
          gameDateCt: row[1],
          gameDate: row[2],
          homeTeam: row[3],
          awayTeam: row[4],
          homeScore: row[5],
          awayScore: row[6],
          neutralSite: row[7],
          location: row[8],
          attendance: row[9],
          source: 'oracle'
        };
      }
      return null;
    } catch (error) {
      logger.error('Error fetching basketball game from Oracle:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch basketball game: ${error.message}`);
    }
  }

  // Get basketball player game stats using two-query approach for performance
  // Query 1: Get all stats from CD_BK_PLAYER_GAME_STATS (fast, indexed)
  // Query 2: Get MINUTES_PLAYED from BASKETBALL.BK_PLAYER_GAME_STATS (targeted)
  async getBasketballPlayerStats(teamId, gameDate, seasonId, gender = 'M') {
    try {
      const conn = await this.connect();
      const leagueId = gender === 'M' ? 2 : 5; // 2 = Men's, 5 = Women's

      // Query 1: Get all player stats (fast - uses indexes on TEAM_ID, GAME_DATE)
      const query1 = `
        SELECT
          PLAYER_ID,
          TEAM_ID,
          FIRST_NAME,
          LAST_NAME,
          GAME_CODE,
          MINUTES_SECONDS,
          FIELD_GOALS_MADE,
          FIELD_GOALS_ATT,
          CASE WHEN FIELD_GOALS_ATT > 0
               THEN ROUND((FIELD_GOALS_MADE / FIELD_GOALS_ATT) * 100, 1)
               ELSE 0 END as FG_PCT,
          THREE_POINT_MADE,
          THREE_POINT_ATT,
          CASE WHEN THREE_POINT_ATT > 0
               THEN ROUND((THREE_POINT_MADE / THREE_POINT_ATT) * 100, 1)
               ELSE 0 END as THREE_PCT,
          FREE_THROWS_MADE,
          FREE_THROWS_ATT,
          CASE WHEN FREE_THROWS_ATT > 0
               THEN ROUND((FREE_THROWS_MADE / FREE_THROWS_ATT) * 100, 1)
               ELSE 0 END as FT_PCT,
          OFFENSIVE_REBOUNDS,
          DEFENSIVE_REBOUNDS,
          TOTAL_REBOUNDS,
          ASSISTS,
          TURNOVERS,
          STEALS,
          BLOCKS,
          PERSONAL_FOULS,
          POINTS
        FROM CUSTOMER_DATA.CD_BK_PLAYER_GAME_STATS
        WHERE SEASON_ID = :seasonId
          AND LEAGUE_ID = ${leagueId}
          AND TEAM_ID = :teamId
          AND SPLIT_NUMBER = 0
          AND TRUNC(GAME_DATE) = TO_DATE(:gameDate, 'YYYY-MM-DD')
          AND UPPER(LAST_NAME) NOT IN ('TEAM', 'TM')
          AND PLAYER_ID IS NOT NULL
      `;

      logger.debug(`ðŸ€ Query 1: Fetching stats from CD_BK_PLAYER_GAME_STATS for teamId=${teamId}, gameDate=${gameDate}`);

      const result1 = await conn.execute(query1, {
        seasonId,
        teamId,
        gameDate
      });

      logger.debug(`ðŸ€ Query 1 returned ${result1.rows ? result1.rows.length : 0} player records`);

      if (!result1.rows || result1.rows.length === 0) {
        return [];
      }

      // Extract GAME_CODE and PLAYER_IDs for second query
      const gameCode = result1.rows[0][4]; // GAME_CODE from first row
      const playerIds = result1.rows.map(row => row[0]); // All PLAYER_IDs

      // Query 2: Get MINUTES_PLAYED for these specific players (fast - targeted WHERE clause)
      const minutesMap = new Map();

      if (gameCode && playerIds.length > 0) {
        try {
          const query2 = `
            SELECT PLAYER_ID, MINUTES_PLAYED
            FROM BASKETBALL.BK_PLAYER_GAME_STATS
            WHERE GAME_CODE = :gameCode
              AND PLAYER_ID IN (${playerIds.map((_, i) => `:playerId${i}`).join(', ')})
          `;

          const bindVars = { gameCode };
          playerIds.forEach((id, i) => {
            bindVars[`playerId${i}`] = id;
          });

          logger.debug(`ðŸ€ Query 2: Fetching minutes from BASKETBALL.BK_PLAYER_GAME_STATS for ${playerIds.length} players`);

          const result2 = await conn.execute(query2, bindVars);

          logger.debug(`ðŸ€ Query 2 returned ${result2.rows ? result2.rows.length : 0} minute records`);

          // Build map of playerId -> minutes
          if (result2.rows) {
            result2.rows.forEach(row => {
              minutesMap.set(row[0], row[1]); // playerId -> minutes
            });
          }
        } catch (error) {
          logger.warn(`âš ï¸ Failed to fetch minutes from BASKETBALL table: ${error.message}`);
          // Continue without minutes data
        }
      }

      // Transform and merge results
      return result1.rows.map(row => {
        const playerId = row[0];
        const minutesFromBK = minutesMap.get(playerId);

        return {
          playerId: playerId,
          teamId: row[1],
          firstName: row[2],
          lastName: row[3],
          fullName: row[2] ? `${row[2]} ${row[3]}` : row[3],
          minutesPlayed: minutesFromBK || row[5] || 0, // Prefer BK table, fallback to CD table
          fieldGoals: {
            made: row[6] || 0,
            attempts: row[7] || 0,
            percentage: row[8] || 0
          },
          threePointers: {
            made: row[9] || 0,
            attempts: row[10] || 0,
            percentage: row[11] || 0
          },
          freeThrows: {
            made: row[12] || 0,
            attempts: row[13] || 0,
            percentage: row[14] || 0
          },
          rebounds: {
            offensive: row[15] || 0,
            defensive: row[16] || 0,
            total: row[17] || 0
          },
          assists: row[18] || 0,
          turnovers: row[19] || 0,
          steals: row[20] || 0,
          blocks: row[21] || 0,
          fouls: row[22] || 0,
          points: row[23] || 0,
          source: 'oracle'
        };
      });
    } catch (error) {
      logger.error('Error fetching basketball player stats from Oracle:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch basketball player stats: ${error.message}`);
    }
  }

  // Get football schedule from CD_FOOTBALL_SCHEDULE
  async getFootballSchedule(teamId, seasonId, startDate = null) {
    try {
      const conn = await this.connect();

      // Build WHERE clause with optional date filter
      let whereClause = `
        WHERE CD.SEASON_ID = :seasonId
          AND (CD.HOME_TEAM_ID = :teamId OR CD.AWAY_TEAM_ID = :teamId)
      `;

      const params = { seasonId, teamId };

      // Add date filter if provided (show games on or after startDate)
      if (startDate) {
        whereClause += `
          AND TRUNC(CD.GAME_DATE_CT) >= TO_DATE(:startDate, 'YYYY-MM-DD')
        `;
        params.startDate = startDate;
      }

      const query = `
        SELECT
          CD.GAME_CODE,
          TO_CHAR(CD.GAME_DATE_CT, 'YYYY-MM-DD') AS GAME_DATE,
          TO_CHAR(CD.GAME_DATE_CT, 'HH24:MI') AS GAME_TIME,
          CD.MAKEUP_DATE,
          CD.STATUS,
          CD.AWAY_TEAM_ID,
          CD.AWAY_TEAM_NAME,
          CD.AWAY_TEAM_NICKNAME,
          CD.AWAY_TEAM_ABBREV,
          CD.HOME_TEAM_ID,
          CD.HOME_TEAM_NAME,
          CD.HOME_TEAM_NICKNAME,
          CD.HOME_TEAM_ABBREV,
          CD.GAME_TYPE_NAME,
          CD.NEUTRAL_SITE,
          CD.STADIUM_ID,
          CD.STADIUM_NAME,
          GV.CITY AS STADIUM_CITY,
          GS.AP_NAME AS STATE,
          CD.TBA_FLAG,
          CD.HOME_CONF_GAME,
          CD.AWAY_CONF_GAME,
          LISTAGG(DISTINCT gt.TV_ABBREV4, ', ') WITHIN GROUP (ORDER BY gt.TV_ABBREV4) AS BROADCASTS,
          LISTAGG(DISTINCT gt.DESCRIPTION, ', ') WITHIN GROUP (ORDER BY gt.DESCRIPTION) AS FULL_BROADCASTS
        FROM CUSTOMER_DATA.CD_FOOTBALL_SCHEDULE CD
        LEFT JOIN GLOBAL.GLB_VENUE GV
          ON CD.STADIUM_ID = GV.VENUE_ID
        LEFT JOIN GLOBAL.GLB_STATE GS
          ON GV.STATE_ID = GS.STATE_ID
        LEFT JOIN CUSTOMER_DATA.CD_FOOTBALL_FRANCHISE CF
          ON CD.STADIUM_ID = CF.STADIUM_ID
          AND CF.SEASON_ID = :seasonId
        LEFT JOIN GLOBAL.TV_SCHEDULES ts
          ON CD.GAME_CODE = ts.GAME_CODE
          AND ts.LEAGUE_ID = 16
        LEFT JOIN GLOBAL.GLB_TV gt
          ON ts.TV_ID = gt.TV_ID
          AND gt.LEAGUE_ID = 16
        ${whereClause}
        GROUP BY
          CD.GAME_CODE,
          CD.GAME_DATE_CT,
          CD.MAKEUP_DATE,
          CD.STATUS,
          CD.AWAY_TEAM_ID,
          CD.AWAY_TEAM_NAME,
          CD.AWAY_TEAM_NICKNAME,
          CD.AWAY_TEAM_ABBREV,
          CD.HOME_TEAM_ID,
          CD.HOME_TEAM_NAME,
          CD.HOME_TEAM_NICKNAME,
          CD.HOME_TEAM_ABBREV,
          CD.GAME_TYPE_NAME,
          CD.NEUTRAL_SITE,
          CD.STADIUM_ID,
          CD.STADIUM_NAME,
          GV.CITY,
          GS.AP_NAME,
          CD.TBA_FLAG,
          CD.HOME_CONF_GAME,
          CD.AWAY_CONF_GAME
        ORDER BY CD.GAME_DATE_CT
      `;

      const result = await conn.execute(query, params);

      if (!result.rows || result.rows.length === 0) {
        return [];
      }

      // Transform to match our schema
      return result.rows.map(row => {
        const isHome = row[9] === teamId; // HOME_TEAM_ID === teamId
        const opponentId = isHome ? row[5] : row[9]; // AWAY_TEAM_ID : HOME_TEAM_ID
        const opponentName = isHome ? row[6] : row[10]; // AWAY_TEAM_NAME : HOME_TEAM_NAME
        const opponentNickname = isHome ? row[7] : row[11]; // AWAY_TEAM_NICKNAME : HOME_TEAM_NICKNAME

        return {
          gameCode: row[0],
          gameId: row[0],
          date: row[1], // GAME_DATE in YYYY-MM-DD format
          time: row[2], // GAME_TIME in HH24:MI format
          makeupDate: row[3],
          status: row[4],

          // Team info
          isHome: isHome,
          isAway: !isHome,
          isNeutral: row[14] === 'Y', // NEUTRAL_SITE
          locationIndicator: row[14] === 'Y' ? 'N' : (isHome ? 'H' : 'A'),

          // Opponent info
          opponentId: opponentId,
          opponent: `${opponentName} ${opponentNickname}`.trim(),
          opponentName: opponentName,
          opponentNickname: opponentNickname,
          opponentAbbrev: isHome ? row[8] : row[12],

          // Venue info
          venue: row[16], // STADIUM_NAME
          venueId: row[15], // STADIUM_ID
          location: row[17] && row[18] ? `${row[17]}, ${row[18]}` : (row[17] || row[18] || null), // CITY, STATE
          city: row[17],
          state: row[18],

          // Game details
          gameType: row[13], // GAME_TYPE_NAME
          tba: row[19] === 'Y', // TBA_FLAG
          isConferenceGame: isHome ? row[20] === 'Y' : row[21] === 'Y', // HOME_CONF_GAME or AWAY_CONF_GAME

          // Media
          tv: row[22], // BROADCASTS (TV_ABBREV4)
          tvFull: row[23], // FULL_BROADCASTS (DESCRIPTION)

          source: 'oracle'
        };
      });
    } catch (error) {
      logger.error('Error fetching football schedule from Oracle:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch football schedule: ${error.message}`);
    }
  }

  // Get basketball schedule for a team (works for both mens and womens)
  async getBasketballSchedule(teamId, seasonId, leagueId, startDate = null) {
    try {
      const conn = await this.connect();

      // Build WHERE clause with optional date filter
      let whereClause = `
        WHERE CD.SEASON_ID = :seasonId
          AND (CD.HOME_TEAM_ID = :teamId OR CD.AWAY_TEAM_ID = :teamId)
      `;

      const params = { seasonId, teamId };

      // Add date filter if provided (show games on or after startDate)
      if (startDate) {
        whereClause += `
          AND TRUNC(CD.GAME_DATE_CT) >= TO_DATE(:startDate, 'YYYY-MM-DD')
        `;
        params.startDate = startDate;
      }

      const query = `
        SELECT
          CD.GAME_CODE,
          TO_CHAR(CD.GAME_DATE_CT, 'YYYY-MM-DD') AS GAME_DATE,
          TO_CHAR(CD.GAME_DATE_CT, 'HH24:MI') AS GAME_TIME,
          CD.MAKEUP_DATE,
          CD.STATUS,
          CD.AWAY_TEAM_ID,
          CD.AWAY_TEAM_NAME,
          CD.AWAY_TEAM_NICKNAME,
          CD.AWAY_TEAM_ABBREV,
          CD.HOME_TEAM_ID,
          CD.HOME_TEAM_NAME,
          CD.HOME_TEAM_NICKNAME,
          CD.HOME_TEAM_ABBREV,
          CD.GAME_TYPE_DESC,
          CD.NEUTRAL_SITE,
          CD.ARENA_ID,
          CD.ARENA_NAME,
          GV.CITY AS ARENA_CITY,
          GS.AP_NAME AS STATE,
          CD.TBA_FLAG,
          CD.CONF_GAME,
          LISTAGG(DISTINCT gt.TV_ABBREV4, ', ') WITHIN GROUP (ORDER BY gt.TV_ABBREV4) AS BROADCASTS,
          LISTAGG(DISTINCT gt.DESCRIPTION, ', ') WITHIN GROUP (ORDER BY gt.DESCRIPTION) AS FULL_BROADCASTS
        FROM CUSTOMER_DATA.CD_BK_SCHEDULE CD
        LEFT JOIN GLOBAL.GLB_VENUE GV
          ON CD.ARENA_ID = GV.VENUE_ID
        LEFT JOIN GLOBAL.GLB_STATE GS
          ON GV.STATE_ID = GS.STATE_ID
        LEFT JOIN CUSTOMER_DATA.CD_BK_FRANCHISE CF
          ON CD.ARENA_ID = CF.ARENA_ID
          AND CF.SEASON_ID = :seasonId
        LEFT JOIN GLOBAL.TV_SCHEDULES ts
          ON CD.GAME_CODE = ts.GAME_CODE
          AND ts.LEAGUE_ID = :leagueId
        LEFT JOIN GLOBAL.GLB_TV gt
          ON ts.TV_ID = gt.TV_ID
          AND gt.LEAGUE_ID = :leagueId
        ${whereClause}
        GROUP BY
          CD.GAME_CODE,
          CD.GAME_DATE_CT,
          CD.MAKEUP_DATE,
          CD.STATUS,
          CD.AWAY_TEAM_ID,
          CD.AWAY_TEAM_NAME,
          CD.AWAY_TEAM_NICKNAME,
          CD.AWAY_TEAM_ABBREV,
          CD.HOME_TEAM_ID,
          CD.HOME_TEAM_NAME,
          CD.HOME_TEAM_NICKNAME,
          CD.HOME_TEAM_ABBREV,
          CD.GAME_TYPE_DESC,
          CD.NEUTRAL_SITE,
          CD.ARENA_ID,
          CD.ARENA_NAME,
          GV.CITY,
          GS.AP_NAME,
          CD.TBA_FLAG,
          CD.CONF_GAME
        ORDER BY CD.GAME_DATE_CT
      `;

      params.leagueId = leagueId; // Add leagueId to params

      const result = await conn.execute(query, params);

      if (!result.rows || result.rows.length === 0) {
        return [];
      }

      // Transform to match our schema
      return result.rows.map(row => {
        const isHome = row[9] === teamId; // HOME_TEAM_ID === teamId
        const opponentId = isHome ? row[5] : row[9]; // AWAY_TEAM_ID : HOME_TEAM_ID
        const opponentName = isHome ? row[6] : row[10]; // AWAY_TEAM_NAME : HOME_TEAM_NAME
        const opponentNickname = isHome ? row[7] : row[11]; // AWAY_TEAM_NICKNAME : HOME_TEAM_NICKNAME

        return {
          gameCode: row[0],
          gameId: row[0],
          date: row[1], // GAME_DATE in YYYY-MM-DD format
          time: row[2], // GAME_TIME in HH24:MI format
          makeupDate: row[3],
          status: row[4],

          // Team info
          isHome: isHome,
          isAway: !isHome,
          isNeutral: row[14] === 'Y', // NEUTRAL_SITE
          locationIndicator: row[14] === 'Y' ? 'N' : (isHome ? 'H' : 'A'),

          // Opponent info
          opponentId: opponentId,
          opponent: `${opponentName} ${opponentNickname}`.trim(),
          opponentName: opponentName,
          opponentNickname: opponentNickname,
          opponentAbbrev: isHome ? row[8] : row[12],

          // Venue info (using arena instead of stadium)
          venue: row[16], // ARENA_NAME
          venueId: row[15], // ARENA_ID
          location: row[17] && row[18] ? `${row[17]}, ${row[18]}` : (row[17] || row[18] || null), // CITY, STATE
          city: row[17],
          state: row[18],

          // Game details
          gameType: row[13], // GAME_TYPE_DESC
          tba: row[19] === 'Y', // TBA_FLAG
          isConferenceGame: row[20] === 'Y', // CONF_GAME

          // Media
          tv: row[21], // BROADCASTS (TV_ABBREV4)
          tvFull: row[22], // FULL_BROADCASTS (DESCRIPTION)

          source: 'oracle'
        };
      });
    } catch (error) {
      logger.error('Error fetching basketball schedule from Oracle:', error.message);
      if (error.code === 'ORACLE_UNAVAILABLE') {
        throw error;
      }
      throw new Error(`Failed to fetch basketball schedule: ${error.message}`);
    }
  }

  transformOracleData(result) {
    if (!result.rows) return [];

    // Helper to convert inches to feet'inches" format
    const inchesToFeetInches = (inches) => {
      if (!inches || isNaN(inches)) return inches;
      const totalInches = parseInt(inches);
      const feet = Math.floor(totalInches / 12);
      const remainingInches = totalInches % 12;
      return `${feet}'${remainingInches}"`;
    };

    return result.rows.map(row => ({
      playerId: row[0],
      firstName: row[1]?.split(' ')[0],
      lastName: row[2],
      teamId: row[3],
      teamName: row[4],
      teamNickname: row[5],
      height: row[6] ? inchesToFeetInches(row[6]) : null, // Convert height
      weight: row[7] ? row[7].toString() : null,
      jersey: row[8] ? row[8].toString() : null,
      position: row[9],
      positionAbbr: row[10],
      year: row[11] ? row[11].toString() : null,
      eligibility: row[12] ? row[12].toString() : null,
      hometown: row[13],
      source: 'oracle',
      displayName: `${row[1]} ${row[2]}`
    }));
  }

  // ========== BASELINE DATA METHODS ==========
  // These methods fetch data from ScrapedDataHistory (baseline) instead of Oracle

  // Get baseline schedule for any sport
  async getBaselineSchedule(moduleId, teamId, sport) {
    try {
      logger.debug(`ðŸ“¦ Fetching baseline schedule for moduleId=${moduleId}, teamId=${teamId}`);

      // Use find() to get ALL games from baseline
      const baselineRecords = await ScrapedDataHistory.find({
        moduleId,
        teamId,
        dataType: 'schedule'
      }).sort({ savedAt: -1 });

      if (!baselineRecords || baselineRecords.length === 0) {
        logger.debug(`ðŸ“¦ No baseline schedule found for ${moduleId} / ${teamId}`);
        return [];
      }

      logger.debug(`ðŸ“¦ Baseline found: ${baselineRecords.length} game records from ${baselineRecords[0].savedAt}`);

      // Extract the data from each baseline record
      const games = baselineRecords.map(record => ({
        ...record.data,
        source: 'baseline'
      }));

      return games;
    } catch (error) {
      logger.error('Error fetching baseline schedule:', error.message);
      throw new Error(`Failed to fetch baseline schedule: ${error.message}`);
    }
  }

  // Get baseline roster for any sport
  async getBaselineRoster(moduleId, teamId, sport) {
    try {
      logger.debug(`ðŸ“¦ Fetching baseline roster for moduleId=${moduleId}, teamId=${teamId}`);

      // Use find() instead of findOne() to get ALL players from baseline
      const baselineRecords = await ScrapedDataHistory.find({
        moduleId,
        teamId,
        dataType: 'roster'
      }).sort({ savedAt: -1 });

      if (!baselineRecords || baselineRecords.length === 0) {
        logger.debug(`ðŸ“¦ No baseline found for ${moduleId} / ${teamId}`);
        return [];
      }

      logger.debug(`ðŸ“¦ Baseline found: ${baselineRecords.length} player records from ${baselineRecords[0].savedAt}`);

      // Extract the data from each baseline record
      const players = baselineRecords.map(record => ({
        ...record.data,
        source: 'baseline'
      }));

      return players;
    } catch (error) {
      logger.error('Error fetching baseline roster:', error.message);
      throw new Error(`Failed to fetch baseline roster: ${error.message}`);
    }
  }

  // Get baseline football game stats (per matchKey)
  async getBaselineFootballStats(moduleId, teamId, gameDate, seasonId, category) {
    try {
      // Generate matchKey similar to how the module does it
      const matchKey = `${teamId}_${seasonId}_${gameDate}`;
      logger.debug(`ðŸ“¦ Fetching baseline football ${category} stats for matchKey=${matchKey}`);

      const baseline = await ScrapedDataHistory.findOne({
        moduleId,
        matchKey,
        dataType: 'stats'
      }).sort({ savedAt: -1 });

      if (!baseline) {
        logger.debug(`ðŸ“¦ No baseline found for ${matchKey}`);
        return [];
      }

      logger.debug(`ðŸ“¦ Baseline found from ${baseline.savedAt}`);

      // Return the baseline data with source marked as 'baseline'
      if (Array.isArray(baseline.data)) {
        return baseline.data.map(player => ({
          ...player,
          source: 'baseline'
        }));
      }

      return [];
    } catch (error) {
      logger.error('Error fetching baseline football stats:', error.message);
      throw new Error(`Failed to fetch baseline football stats: ${error.message}`);
    }
  }

  // Get baseline basketball game stats (per matchKey)
  async getBaselineBasketballStats(moduleId, teamId, gameDate, seasonId, gender = 'M') {
    try {
      // Generate matchKey similar to how the module does it
      const matchKey = `${teamId}_${seasonId}_${gameDate}`;
      logger.debug(`ðŸ“¦ Fetching baseline basketball stats for matchKey=${matchKey}`);

      const baseline = await ScrapedDataHistory.findOne({
        moduleId,
        matchKey,
        dataType: 'stats'
      }).sort({ savedAt: -1 });

      if (!baseline) {
        logger.debug(`ðŸ“¦ No baseline found for ${matchKey}`);
        return [];
      }

      logger.debug(`ðŸ“¦ Baseline found from ${baseline.savedAt}`);

      // Return the baseline data with source marked as 'baseline'
      if (Array.isArray(baseline.data)) {
        return baseline.data.map(player => ({
          ...player,
          source: 'baseline'
        }));
      }

      return [];
    } catch (error) {
      logger.error('Error fetching baseline basketball stats:', error.message);
      throw new Error(`Failed to fetch baseline basketball stats: ${error.message}`);
    }
  }

  // Generic baseline stats getter - works for any module/matchKey
  async getBaselineStats(moduleId, matchKey) {
    try {
      logger.debug(`ðŸ“¦ Fetching baseline stats for moduleId=${moduleId}, matchKey=${matchKey}`);

      const baseline = await ScrapedDataHistory.findOne({
        moduleId,
        matchKey,
        dataType: 'stats'
      }).sort({ savedAt: -1 });

      if (!baseline) {
        logger.debug(`ðŸ“¦ No baseline found for ${matchKey}`);
        return [];
      }

      logger.debug(`ðŸ“¦ Baseline found from ${baseline.savedAt}`);

      // Return the baseline data with source marked as 'baseline'
      if (Array.isArray(baseline.data)) {
        return baseline.data.map(player => ({
          ...player,
          source: 'baseline'
        }));
      }

      return [];
    } catch (error) {
      logger.error('Error fetching baseline stats:', error.message);
      throw new Error(`Failed to fetch baseline stats: ${error.message}`);
    }
  }

  /**
   * Fetch NBA schedule data from Oracle
   * @param {number} teamId - The team's statsId (Oracle team ID)
   * @param {number} seasonId - Season ID (e.g., 202501)
   * @param {string} startDate - Start date in YYYY-MM-DD format (optional)
   * @returns {Promise<Array>} Array of games
   */
  async getNBASchedule(teamId, seasonId = 202501, startDate = null) {
    try {
      const conn = await this.connect();
      const NBA_LEAGUE_ID = 1;

      // Default to start of season if no startDate provided
      const defaultStartDate = '2024-10-22';
      // If startDate is provided and is after June 2025, extend end date to cover it
      const effectiveStartDate = startDate || defaultStartDate;
      const defaultEndDate = '2026-05-30'; // Extended to cover full 2025-26 season

      const sql = `
        SELECT
          s.*,
          /* ET wall-clock ISO */
          CASE
            WHEN s.GAME_DATE_CT = TRUNC(s.GAME_DATE_CT) THEN NULL
            ELSE TO_CHAR(
                   FROM_TZ(CAST(s.GAME_DATE_CT AS TIMESTAMP), 'America/Chicago')
                   AT TIME ZONE 'America/New_York',
                   'YYYY-MM-DD"T"HH24:MI:SS'
                 )
          END AS GAME_DATETIME_EST,
          CASE
            WHEN s.GAME_DATE_CT = TRUNC(s.GAME_DATE_CT) THEN NULL
            ELSE TO_CHAR(
                   FROM_TZ(CAST(s.GAME_DATE_CT AS TIMESTAMP), 'America/Chicago')
                   AT TIME ZONE 'America/New_York',
                   'HH24:MI:SS'
                 )
          END AS GAME_TIME_EST,

          /* ET calendar date */
          TO_CHAR(
            FROM_TZ(CAST(s.GAME_DATE_CT AS TIMESTAMP), 'America/Chicago')
            AT TIME ZONE 'America/New_York',
            'YYYY-MM-DD'
          ) AS GAME_DATE_EST,

          /* TV from GLOBAL */
          (
            SELECT LISTAGG(DISTINCT gt.TV_ABBREV4, ', ') WITHIN GROUP (ORDER BY gt.TV_ABBREV4)
              FROM global.tv_schedules ts
              JOIN global.glb_tv gt
                ON gt.TV_ID = ts.TV_ID
               AND gt.LEAGUE_ID = :leagueId
             WHERE ts.GAME_CODE = s.GAME_CODE
               AND ts.LEAGUE_ID = :leagueId
          ) AS TV_ABBREVS
        FROM   CUSTOMER_DATA.CD_BK_SCHEDULE s
        WHERE  s.SEASON_ID = :seasonId
          AND  (s.HOME_TEAM_ID_1032 = :teamId OR s.AWAY_TEAM_ID_1032 = :teamId)
          AND  s.GAME_DATE_CT BETWEEN TO_DATE(:startDate,'YYYY-MM-DD')
                                   AND TO_DATE(:endDate,'YYYY-MM-DD') + 1
        ORDER BY s.GAME_DATE_CT, s.GAME_CODE
      `;

      const binds = {
        seasonId,
        teamId: Number(teamId), // Ensure teamId is a number for Oracle
        startDate: effectiveStartDate,
        endDate: defaultEndDate,
        leagueId: NBA_LEAGUE_ID
      };

      logger.debug('NBA Schedule Oracle Query Parameters:', binds);

      const opts = { outFormat: oracledb.OUT_FORMAT_OBJECT };
      const result = await conn.execute(sql, binds, opts);

      logger.debug(`NBA Schedule Oracle Query returned ${result.rows.length} games`);

      return result.rows.map(r => {
        // Pretty "h:mm am/pm ET" from GAME_TIME_EST
        let gameTimeEst = null;
        if (r.GAME_TIME_EST) {
          const [HH, MM] = r.GAME_TIME_EST.split(':');
          let h = Number(HH);
          const ampm = h >= 12 ? 'pm' : 'am';
          h = ((h + 11) % 12) + 1;
          gameTimeEst = `${h}:${MM} ${ampm} ET`;
        }

        let makeup = null;
        if (r.MAKEUP_DATE) {
          const m2 = r.MAKEUP_DATE;
          const y2 = m2.getFullYear();
          const mm2 = String(m2.getMonth() + 1).padStart(2, '0');
          const dd2 = String(m2.getDate()).padStart(2, '0');
          makeup = `${y2}-${mm2}-${dd2}`;
        }

        // Parse and sort broadcasters for consistent comparison
        const broadcasters = (r.TV_ABBREVS || '')
          .split(',')
          .map(s => s.trim())
          .filter(Boolean);
        const sortedBroadcasters = [...new Set(broadcasters)].sort();

        return {
          gameId: r.GAME_CODE,
          gameDate: r.GAME_DATE_EST, // ET calendar date
          date: r.GAME_DATE_EST, // Alias for compatibility
          dateTimeEst: r.GAME_DATETIME_EST || null,
          time: gameTimeEst, // For comparison compatibility
          gameTimeEst,
          status: r.STATUS,
          postponed: r.POSTPONED === 'Y',
          suspended: r.SUSPENDED === 'Y',
          makeUpDate: makeup,
          venue: r.ARENA_NAME, // For comparison compatibility
          location: r.ARENA_NAME, // For comparison compatibility
          arena: {
            id: r.ARENA_ID,
            name: r.ARENA_NAME
          },
          neutralSite: r.NEUTRAL_SITE === 'Y',
          tbaFlag: r.TBA_FLAG === 'Y',
          totalQuarters: r.QUARTERS,
          tv: sortedBroadcasters.join(', '), // For comparison compatibility (sorted)
          tvArray: sortedBroadcasters, // Individual broadcasters for granular comparison
          broadcasters: sortedBroadcasters,
          homeTeam: {
            teamId: r.HOME_TEAM_ID_1032,
            name: r.HOME_TEAM_NAME,
            nickname: r.HOME_TEAM_NICKNAME,
            abbrev: r.HOME_TEAM_ABBREV,
            score: r.HOME_SCORE
          },
          awayTeam: {
            teamId: r.AWAY_TEAM_ID_1032,
            name: r.AWAY_TEAM_NAME,
            nickname: r.AWAY_TEAM_NICKNAME,
            abbrev: r.AWAY_TEAM_ABBREV,
            score: r.AWAY_SCORE
          },
          source: 'oracle'
        };
      });
    } catch (error) {
      logger.error('Error fetching NBA schedule from Oracle:', error.message);
      throw new Error(`Failed to fetch NBA schedule: ${error.message}`);
    }
  }

  /**
   * Fetch NBA boxscore data from Oracle for a specific game
   * Uses TEAM_ID + GAME_DATE for matching (more reliable than GAME_CODE)
   * @param {string} statsId - Stats ID / Oracle TEAM_ID (e.g., "1610612737" for Atlanta Hawks)
   * @param {string} gameDate - Game date in YYYY-MM-DD format
   * @param {number} seasonId - Season ID (e.g., 202501)
   * @returns {Promise<Array>} Array of player stats for both teams in the game
   */
  async getNBABoxscore(statsId, gameDate, seasonId = 202501) {
    try {
      const conn = await this.connect();

      logger.debug(`ðŸ€ NBA Boxscore Oracle Query: statsId=${statsId}, gameDate=${gameDate}, seasonId=${seasonId}`);

      // First get the GAME_CODE for this team's game on this date
      const gameCodeSql = `
        SELECT DISTINCT GAME_CODE
          FROM CUSTOMER_DATA.CD_BK_PLAYER_GAME_STATS
         WHERE SEASON_ID    = :seasonId
           AND SPLIT_NUMBER = 0
           AND TEAM_ID      = :statsId
           AND TRUNC(GAME_DATE) = TO_DATE(:gameDate, 'YYYY-MM-DD')
      `;

      const gameCodeResult = await conn.execute(gameCodeSql, { statsId, gameDate, seasonId }, { outFormat: oracledb.OUT_FORMAT_OBJECT });

      if (gameCodeResult.rows.length === 0) {
        logger.debug(`ðŸ€ No game found in Oracle for team ${statsId} on ${gameDate}`);
        return [];
      }

      const gameCode = gameCodeResult.rows[0].GAME_CODE;
      logger.debug(`ðŸ€ Found GAME_CODE: ${gameCode} for team ${statsId} on ${gameDate}`);

      // Now get ALL players from this game (both teams)
      const sql = `
        SELECT *
          FROM CUSTOMER_DATA.CD_BK_PLAYER_GAME_STATS
         WHERE SEASON_ID    = :seasonId
           AND SPLIT_NUMBER = 0
           AND GAME_CODE    = :gameCode
      `;

      const binds = { gameCode, seasonId };
      const opts = { outFormat: oracledb.OUT_FORMAT_OBJECT };
      const result = await conn.execute(sql, binds, opts);

      logger.debug(`ðŸ€ NBA Boxscore Oracle Query returned ${result.rows.length} raw rows`);

      // Helper to convert seconds to "MM:SS" format (zero-padded to match NBA scraped format)
      const secondsToMinutes = (totalSeconds) => {
        if (totalSeconds === null || totalSeconds === undefined) return '00:00';
        const mins = Math.floor(totalSeconds / 60);
        const secs = totalSeconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      };

      // Only include players who actually played (GAMES = 1)
      return result.rows
        .filter(r => r.GAMES === 1)
        .map(r => ({
          playerName:            `${r.MONIKER || r.FIRST_NAME} ${r.LAST_NAME}`.trim(),
          team:                  (r.HOME_TEAM === 'Y' || Number(r.HOME_TEAM) === 1) ? 'home' : 'away',
          minutes:               secondsToMinutes(r.MINUTES_SECONDS),
          points:                r.POINTS,
          fieldGoalsMade:        r.FIELD_GOALS_MADE,
          fieldGoalsAttempted:   r.FIELD_GOALS_ATT,
          threePointersMade:     r.THREE_POINT_MADE,
          threePointersAttempted: r.THREE_POINT_ATT,
          freeThrowsMade:        r.FREE_THROWS_MADE,
          freeThrowsAttempted:   r.FREE_THROWS_ATT,
          offensiveRebounds:     r.OFFENSIVE_REBOUNDS,
          defensiveRebounds:     r.DEFENSIVE_REBOUNDS,
          rebounds:              r.TOTAL_REBOUNDS,
          assists:               r.ASSISTS,
          steals:                r.STEALS,
          blocks:                r.BLOCKS,
          blocksReceived:        r.BLOCKS_RECEIVED,
          turnovers:             r.TURNOVERS,
          personalFouls:         r.PERSONAL_FOULS,
          technicalFouls:        r.TECHNICAL_FOUL,
          foulsReceived:         r.FOULS_RECEIVED,
          plusMinusPoints:       r.PLUS_MINUS,
          dunks:                 r.DUNKS,
          tipIns:                r.TIP_INS,
          pointsFastBreak:       r.FB_POINTS,
          pointsInThePaint:      r.POINTS_IN_THE_PAINT,
          pointsSecondChance:    r.POINTS_SECOND_CHANCE,
          source:                'oracle'
        }));
    } catch (error) {
      logger.error('Error fetching NBA boxscore from Oracle:', error.message);
      throw new Error(`Failed to fetch NBA boxscore: ${error.message}`);
    }
  }

  async close() {
    if (this.connection) {
      try {
        await this.connection.close();
        this.connection = null;
      } catch (error) {
        logger.error('Error closing Oracle connection:', error);
      }
    }
  }
}

module.exports = new OracleService();

  // Oracle Database Connection (pre-filled, users only enter username/password)
  oracle: {
    connectString: 'exadata2-cluster.stats.com:1521/bladerac_usr.stats.com'
    // Username and password provided by user at login
  },